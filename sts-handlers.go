/*
 * Federator, (C) 2017 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cmd

import (
	"crypto/sha1"
	"encoding/base64"
	"encoding/xml"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"time"

	router "github.com/gorilla/mux"
	"github.com/minio/saml"

	"github.com/minio/federator/pkg/credentials"
	"github.com/minio/federator/pkg/logger"
)

const (
	// STS API version.
	stsAPIVersion = "2011-06-15"
)

// stsAPIHandlers implements and provides http handlers for AWS STS API.
type stsAPIHandlers struct{}

// registerSTSRouter - registers AWS STS compatible APIs.
func registerSTSRouter(mux *router.Router) {
	// Initialize STS.
	sts := &stsAPIHandlers{}

	// STS Router
	stsRouter := mux.NewRoute().PathPrefix("/").Subrouter()

	// AssumeRoleWithSAML
	stsRouter.Methods("POST").HandlerFunc(sts.AssumeRoleWithSAMLHandler)
}

// AssumedRoleUser - The identifiers for the temporary security credentials that
// the operation returns. Please also see https://docs.aws.amazon.com/goto/WebAPI/sts-2011-06-15/AssumedRoleUser
type AssumedRoleUser struct {
	// The ARN of the temporary security credentials that are returned from the
	// AssumeRole action. For more information about ARNs and how to use them in
	// policies, see IAM Identifiers (http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html)
	// in Using IAM.
	//
	// Arn is a required field
	Arn string

	// A unique identifier that contains the role ID and the role session name of
	// the role that is being assumed. The role ID is generated by AWS when the
	// role is created.
	//
	// AssumedRoleId is a required field
	AssumedRoleID string `xml:"AssumeRoleId"`
	// contains filtered or unexported fields
}

// AssumeRoleWithSAMLResult - Contains the response to a successful AssumeRoleWithSAML request,
// including temporary AWS credentials that can be used to make AWS requests.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/sts-2011-06-15/AssumeRoleWithSAMLResponse
type AssumeRoleWithSAMLResult struct {
	// The identifiers for the temporary security credentials that the operation
	// returns.
	AssumedRoleUser AssumedRoleUser `xml:",omitempty"`

	// The value of the Recipient attribute of the SubjectConfirmationData element
	// of the SAML assertion.
	Audience string `xml:",omitempty"`

	// The temporary security credentials, which include an access key ID, a secret
	// access key, and a security (or session) token.
	//
	// Note: The size of the security token that STS APIs return is not fixed. We
	// strongly recommend that you make no assumptions about the maximum size. As
	// of this writing, the typical size is less than 4096 bytes, but that can vary.
	// Also, future updates to AWS might require larger sizes.
	Credentials credentials.Credential `xml:",omitempty"`

	// The value of the Issuer element of the SAML assertion.
	Issuer string `xml:",omitempty"`

	// A hash value based on the concatenation of the Issuer response value, the
	// AWS account ID, and the friendly name (the last part of the ARN) of the SAML
	// provider in IAM. The combination of NameQualifier and Subject can be used
	// to uniquely identify a federated user.
	//
	// The following pseudocode shows how the hash value is calculated:
	//
	// BASE64 ( SHA1 ( "https://example.com/saml" + "123456789012" + "/MySAMLIdP"
	// ) )
	NameQualifier string `xml:",omitempty"`

	// A percentage value that indicates the size of the policy in packed form.
	// The service rejects any policy with a packed size greater than 100 percent,
	// which means the policy exceeded the allowed space.
	PackedPolicySize int64 `xml:",omitempty"`

	// The value of the NameID element in the Subject element of the SAML assertion.
	Subject string `xml:",omitempty"`

	// The format of the name ID, as defined by the Format attribute in the NameID
	// element of the SAML assertion. Typical examples of the format are transient
	// or persistent.
	//
	// If the format includes the prefix urn:oasis:names:tc:SAML:2.0:nameid-format,
	// that prefix is removed. For example, urn:oasis:names:tc:SAML:2.0:nameid-format:transient
	// is returned as transient. If the format includes any other prefix, the format
	// is returned with no modifications.
	SubjectType string `xml:",omitempty"`
}

func parseSAMLAssertion(r *http.Request) (*saml.Assertion, error) {
	rawResponseBuf, err := base64.StdEncoding.DecodeString(r.PostForm.Get("SAMLAssertion"))
	if err != nil {
		return nil, err
	}

	var resp saml.Response
	if err = xml.Unmarshal(rawResponseBuf, &resp); err != nil {
		return nil, err
	}
	if resp.Destination != globalSAMLProvider.AcsURL.String() {
		err = fmt.Errorf("`Destination` does not match AcsURL (expected %q)",
			globalSAMLProvider.AcsURL.String())
		return nil, err
	}

	now := time.Now().UTC()
	if resp.IssueInstant.Add(saml.MaxIssueDelay).Before(now) {
		err = fmt.Errorf("IssueInstant expired at %s", resp.IssueInstant.Add(saml.MaxIssueDelay))
		return nil, err
	}

	if resp.Issuer.Value != globalSAMLProvider.IDPMetadata.EntityID {
		err = fmt.Errorf("Issuer does not match the IDP metadata (expected %q)",
			globalSAMLProvider.IDPMetadata.EntityID)
		return nil, err
	}
	if resp.Status.StatusCode.Value != saml.StatusSuccess {
		return nil, fmt.Errorf("Status code was %s, expected %s", resp.Status.StatusCode.Value,
			saml.StatusSuccess)
	}

	// TODO add more checks.
	return resp.Assertion, nil
}

func (sts *stsAPIHandlers) AssumeRoleWithSAMLHandler(w http.ResponseWriter, r *http.Request) {
	// This is an unauthenticated request.
	if err := r.ParseForm(); err != nil {
		logger.ErrorIf(err, "Unable to parse incoming data.")
		writeSTSErrorResponse(w, ErrSTSMalformedPolicyDocument)
		return
	}

	if r.PostForm.Get("Version") != stsAPIVersion {
		logger.ErrorIf(errors.New("API version mismatch"), "")
		writeSTSErrorResponse(w, ErrSTSMalformedPolicyDocument)
		return
	}

	assertion, err := parseSAMLAssertion(r)
	if err != nil {
		logger.ErrorIf(err, "Unable to parse SAML response")
		writeSTSErrorResponse(w, ErrSTSMalformedPolicyDocument)
		return
	}

	expirationTime := time.Now().UTC().Add(time.Duration(240) * time.Minute) // Defaults to 4hrs.
	if r.PostForm.Get("DurationSeconds") != "" {
		expirationSecs, serr := strconv.ParseInt(r.PostForm.Get("DurationSeconds"), 10, 64)
		if serr != nil {
			logger.ErrorIf(serr, "Unable to parse DurationSeconds")
			writeSTSErrorResponse(w, ErrSTSMalformedPolicyDocument)
			return
		}

		// The duration, in seconds, of the role session.
		// The value can range from 900 seconds (15 minutes)
		// to 14400 seconds (4 hours). By default, the value
		// is set to 14400 seconds.
		if expirationSecs < 900 {
			expirationSecs = 900
		}

		if expirationSecs > 14400 {
			expirationSecs = 14400
		}

		expirationTime = time.Now().UTC().Add(time.Duration(expirationSecs) * time.Second)
	}

	cred, err := credentials.NewCredentialWithExpiration(expirationTime)
	if err != nil {
		logger.ErrorIf(err, "Failed to general new credentials with expiration.")
		writeSTSErrorResponse(w, ErrSTSMalformedPolicyDocument)
		return
	}

	h := sha1.New()
	io.WriteString(h, assertion.Issuer.Value+"0000"+"myidp")
	nq := base64.StdEncoding.EncodeToString(h.Sum(nil))

	// Set the newly generated credentials.
	globalServerCreds.Set(cred)

	// Save newly generated credentials to disk.
	if err = globalServerCreds.Save(); err != nil {
		logger.ErrorIf(err, "Unable to save STS credentials")
		writeSTSErrorResponse(w, ErrSTSInternalError)
		return
	}

	samlOutput := &AssumeRoleWithSAMLResult{
		Audience:      assertion.Subject.SubjectConfirmations[0].SubjectConfirmationData.Recipient,
		Credentials:   cred,
		Subject:       assertion.Subject.NameID.Value,
		SubjectType:   assertion.Subject.NameID.Format,
		Issuer:        assertion.Issuer.Value,
		NameQualifier: nq,
	}

	encodedSuccessResponse := encodeResponse(samlOutput)
	writeSuccessResponseXML(w, encodedSuccessResponse)
}
